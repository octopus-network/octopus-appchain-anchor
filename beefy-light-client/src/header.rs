use beefy_merkle_tree::{Hash, Keccak256};
use codec::{Decode, Encode};

#[derive(Debug, Default, Encode, Decode)]
pub struct Header {
    /// The parent hash.
    pub parent_hash: Hash,
    /// The block number.
    pub number: u32,
    /// The state trie merkle root
    pub state_root: Hash,
    /// The merkle root of the extrinsics.
    pub extrinsics_root: Hash,
    /// A chain-specific digest of data useful for light clients or referencing auxiliary data.
    pub digest: Digest,
}

impl Header {
    pub fn hash(&self) -> Hash {
        Keccak256::hash(&self.encode())
    }

    pub fn get_other(&self) -> Option<Vec<u8>> {
        self.digest.logs.iter().find_map(|item| match item {
            DigestItem::Other(data) => Some(data.clone()),
            _ => None,
        })
    }
}

#[derive(Debug, Default, Encode, Decode)]
pub struct Digest {
    /// A list of logs in the digest.
    pub logs: Vec<DigestItem>,
}

/// Consensus engine unique ID.
pub type ConsensusEngineId = [u8; 4];

#[derive(Debug, Encode, Decode)]
pub enum DigestItem {
    /// System digest item that contains the root of changes trie at given
    /// block. It is created for every block iff runtime supports changes
    /// trie creation.
    ChangesTrieRoot(Hash),

    /// A pre-runtime digest.
    ///
    /// These are messages from the consensus engine to the runtime, although
    /// the consensus engine can (and should) read them itself to avoid
    /// code and state duplication. It is erroneous for a runtime to produce
    /// these, but this is not (yet) checked.
    ///
    /// NOTE: the runtime is not allowed to panic or fail in an `on_initialize`
    /// call if an expected `PreRuntime` digest is not present. It is the
    /// responsibility of a external block verifier to check this. Runtime API calls
    /// will initialize the block without pre-runtime digests, so initialization
    /// cannot fail when they are missing.
    PreRuntime(ConsensusEngineId, Vec<u8>),

    /// A message from the runtime to the consensus engine. This should *never*
    /// be generated by the native code of any consensus engine, but this is not
    /// checked (yet).
    Consensus(ConsensusEngineId, Vec<u8>),

    /// Put a Seal on it. This is only used by native code, and is never seen
    /// by runtimes.
    Seal(ConsensusEngineId, Vec<u8>),

    /// Digest item that contains signal from changes tries manager to the
    /// native code.
    ChangesTrieSignal(ChangesTrieSignal),

    /// Some other thing. Unsupported and experimental.
    Other(Vec<u8>),

    /// An indication for the light clients that the runtime execution
    /// environment is updated.
    ///
    /// Currently this is triggered when:
    /// 1. Runtime code blob is changed or
    /// 2. `heap_pages` value is changed.
    RuntimeEnvironmentUpdated,
}

#[derive(Debug, Encode, Decode)]
pub enum ChangesTrieSignal {
    /// New changes trie configuration is enacted, starting from **next block**.
    ///
    /// The block that emits this signal will contain changes trie (CT) that covers
    /// blocks range [BEGIN; current block], where BEGIN is (order matters):
    /// - LAST_TOP_LEVEL_DIGEST_BLOCK+1 if top level digest CT has ever been created using current
    ///   configuration AND the last top level digest CT has been created at block
    ///   LAST_TOP_LEVEL_DIGEST_BLOCK;
    /// - LAST_CONFIGURATION_CHANGE_BLOCK+1 if there has been CT configuration change before and
    ///   the last configuration change happened at block LAST_CONFIGURATION_CHANGE_BLOCK;
    /// - 1 otherwise.
    NewConfiguration(Option<ChangesTrieConfiguration>),
}

#[derive(Debug, Default, Encode, Decode)]
pub struct ChangesTrieConfiguration {
    /// Interval (in blocks) at which level1-digests are created. Digests are not
    /// created when this is less or equal to 1.
    pub digest_interval: u32,
    /// Maximal number of digest levels in hierarchy. 0 means that digests are not
    /// created at all (even level1 digests). 1 means only level1-digests are created.
    /// 2 means that every digest_interval^2 there will be a level2-digest, and so on.
    /// Please ensure that maximum digest interval (i.e. digest_interval^digest_levels)
    /// is within `u32` limits. Otherwise you'll never see digests covering such intervals
    /// && maximal digests interval will be truncated to the last interval that fits
    /// `u32` limits.
    pub digest_levels: u32,
}

#[cfg(test)]
mod tests {
    use super::*;
    use hex_literal::hex;

    #[test]
    fn decode_header_works_1() {
        let encoded_header = hex!("08c155c0053d38c11e5c73da25f718ce1babf788a5de3350d1d6119930723f47f1050cbf12f48249c92c903354e58a656649ab472b2cf0bd7bcbb598eeb0e198e6697dafe7aa4aa6e9184ceb07b5e7711308657e9bd1285473216523a73a2105561f0c06424142453402000000006877862000000000044245454684039d0139d49a88465111c314804cd5af0b43d3323885ce26788844f43b9b060227054241424501011eaff7a42f1f64674e1d81f61c0dd4b770e92cc9b0cac86508915aa7ce500d0bc04a14dea8fee8f291c444b28a6efcf9fac8f9b1aab686b7243294bcb1e0de87");

        let header = Header::decode(&mut &encoded_header[..]);
        println!("header: {:?}", header);

        assert_eq!(header.is_ok(), true);
    }

    #[test]
    fn decode_header_works_2() {
        let encoded_header = hex!("adde90798445cf0edcf36869cc414306a3c49922b982537496b626ea11a013b08902b1b39333299244ba0ba961cfd36976e4c16b2cb76295dd7649454ab128a2e2a3bbee729f4a811a2a35f85c382f72d060a168ffca20a21d08541f01f32ca54a3c0c06424142453402000000008e76862000000000044245454684032f6d4a19f8f0341a0a66f325780fac42b8ad1c0a51a58273380b2d66371464e005424142450101820a4c8425220ce42867228a206269db31beca93e9aece18558ca8f8e55bf473ae2e3950a9aad9b40d7899f94e3df8722bc2bc4b42816cc77ed5c290b805f38f");

        let header = Header::decode(&mut &encoded_header[..]);
        println!("header: {:?}", header);

        assert_eq!(header.is_ok(), true);
    }
}
